# The QuantGov Corpus

## Getting Started

With the quantgov library installed, create a corpus with the following command:

``` {.bash}
quantgov start corpus CORPUS_NAME
```

See the [tutorial](http://docs.quantgov.org/tutorial/first_corpus) for more details.

## Basic Structure

A corpus represents a set of documents and organizes them in a way that allows the user to perform analysis on the text. Creating a corpus is the first step for producing a dataset from a set of documents, like the RegData project which produces data from *The Code of Federal Regulations*.

The root directory for a QuantGov corpus should contain:

- A `Snakefile` to manage the workflow of the corpus.
- A module named `driver.py` that implements the corpus driver interface.
- A subdirectory named `scripts` containing the scripts needed to obtain, organize, and prepare the documents that make up the corpus, as well as to generate any metadata for the corpus.
- A subdirectory named `data` that holds any intermediate data generated during preparation of the corpus.

One file that each corpus should generate is a csv file in the `data` directory named `metadata.csv`. This file should contain any additional information about individual documents that may be relevant. For example, the `metadata.csv` generated by the CFR corpus includes which agency and department authored each individual CFR part, as well as the restriction and word count for each part.

## Corpus Driver Interface

The driver serves two important functions. First, it specifies how the corpus should be indexed. An index is one or more values that, taken together, uniquely identify each document in the corpus. An index can be as simple as an id number, or it can be more descriptive. For the CFR corpus, each document, representing a single subdivision called a part, is represented by three pieces of metadata: the year of the CFR edition that contains it, the title that contains it, and the part number.

The components of the index are named in an argument of the driver's function called `index_labels`. They may be passed to the driver constructor by the user, identified by a regex pattern (name pattern corpus driver), or identified by the column names of `index.csv` (index driver). (See below for more details on the different kinds of builtin drivers.) For example, the CFR driver is passed the argument `index_labels = ['year', 'title', 'part']`. A corpus using a simple document numbering system may use `index_label = 'id'`.

The second important feature of the driver is that it provides a function named `stream.` The `stream` function should return an iterable (in most cases, a generator) that emits the index value (or values) and text of each document in the corpus. Thus, the first item emitted by `driver.stream()` in the CFR corpus might be `(1975, 1, 1), "Text of the 1975 CFR, Title 1, Part 1".`

Drivers may implement other features (such as only streaming a subset of documents based on the index), but these will be non-standard, and estimators should not expect them as a matter of course.

### Builtin Drivers

The QuantGov library includes three builtin corpus drivers:

- **Recursive directory corpus driver** serves a corpus with files organized in a directory. The index labels are defined by the user in the driver and the index values are the names of the subdirectories. Most official QuantGov corpora use this framework. Below is the code to produce the recursive directory driver for the RegData corpus.

```
driver = quantgov.corpora.RecursiveDirectoryCorpusDriver(
    directory=Path(__file__).parent.joinpath('data', 'clean'),
    index_labels=('year', 'title', 'part')
)
```

- **Name pattern corpus driver** serves a corpus with all files in a single directory and filenames defined by a regular expression. The index labels are the group names contained in the regular expression in the order that they appear. Below is an example of the code that could be used to produce a name pattern driver for the RegData corpus.

```
driver = quantgov.corpora.NamePatternCorpusDriver(
    directory=Path(__file__).parent.joinpath('data', 'clean'),
    pattern=r'(?P<year>\d{4})-(?P<title>\d+)-(?P<part>\d+)'
)
```

- **Index driver** serves a corpus using an index csv where the final column is the path to the file and the other columns form the index. The index labels are taken from the csv header and the index values are taken from the csv contents. Below is an example of the code that could be used to produce an index driver.

```
driver = quantgov.corpora.IndexDriver(
    directory=Path(__file__).parent.joinpath('data', 'clean'),
    index='data/index.csv'
)
```

## Corpus Metadata

Relevant metadata will vary from corpus to corpus. Metadata can be generated from one of two sources: from the text itself or from additional external information. In the first case, the best practice is to write scripts that understand the corpus driver interface, and can therefore be used in other corpora. In the second case, the external resources should be stored in a read-only databank separate from the corpus itself. An example of this approach is the agency attribution in the CFR corpus, which relies on a set of documents separate from the main CFR text.

## Builtin Functions

The QuantGov library includes several builtin text-analysis functions for use on the documents in the corpus. Each of these functions can be used on the command line with the following command:

``` {.bash}
quantgov corpus FUNCTION_NAME CORPUS_PATH
```

- **Word counter** counts the number of words in each document. A "word" can be user-defined by a regular expression. The default regular expression is `r'\b\w+\b'`.

- **Occurrence counter** counts the number of specified words in each document. The user must specify one or more words to be counted.

- The following complexity measures estimate the linguistic complexity of each document:

    - **Shannon Entropy** estimates the complexity of the text in each document based on the method used in [this paper](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2307352). Higher numbers suggest the content of the text is more difficult to predict, and thus more uncertain and complex.
    - **Conditional counter** counts the number of conditionals in each document (words like "if", "but", "except", etc.) as an estimate of complexity.
    - **Sentence length** measures the average length of sentences within each document. Longer average sentence length suggests greater complexity.

- **Sentiment analysis** estimates the polarity and subjectivity of the language in each document. Polarity is measured from -1 to 1, with -1 respresenting very negative language and 1 representing very positive language. Subjectivity is measured from 0 to 1, with 0 representing very objective text and 1 representing very subjective text.

## Writing a New Corpus

The organization of the corpus will depend on its purpose. However, there are three principle problems to solve in the creation of any new corpus:

1. How can the text be obtained and, if necessary, converted to plain text?
2. What is the logical unit of analysis for the corpus?
3. How can the text be organized to best reflect the unit of analysis?

The first problem will determine the scripts needed for downloading or otherwise obtaining and cleaning the text from its published format. The second will determine the index for the corpus, and identify what makes an individual document, appropriate to be served through the driver. The third will determine how the driver is actually implemented.

## Official QuantGov Corpora

Official QuantGov corpora are branches of the corpus repository, available on GitHub at <https://github.com/QuantGov/corpus>. The `master` branch of this repository is the Generic Corpus, which serves all files in the data/clean folder, with the file path as the index. See the `Snakefile` for more details.

## Submitting a New Official Corpus

Complete corpora may be considered to be added as official QuantGov copora. If accepted, a new branch will be created to which a pull request can be made. Additions to the official corpora are at the sole discretion of the QuantGov team.
